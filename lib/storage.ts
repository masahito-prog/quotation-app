import { supabase } from "./supabase";
import { Quote } from "./types";

// Helper to convert DB snake_case to App camelCase
const mapToQuote = (data: any): Quote => ({
    id: data.id,
    quoteNumber: data.quote_number,
    status: data.status,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    customerName: data.customer_name,
    honorific: data.honorific,
    issueDate: data.issue_date,
    expiryDate: data.expiry_date,
    taxRate: data.tax_rate,
    subtotal: data.subtotal,
    taxAmount: data.tax_amount,
    totalAmount: data.total_amount,
    items: data.items || [], // JSONB comes back as object/array
    remarks: data.remarks,
});

// Helper to convert App camelCase to DB snake_case
const mapToDb = (quote: Quote) => ({
    // id is auto-generated by DB on insert if undefined, but we need it for updates.
    // simpler to let DB handle ID generation for inserts, or use the one provided.
    id: quote.id || undefined,
    quote_number: quote.quoteNumber,
    status: quote.status,
    customer_name: quote.customerName,
    honorific: quote.honorific,
    issue_date: quote.issueDate,
    expiry_date: quote.expiryDate,
    tax_rate: quote.taxRate,
    subtotal: quote.subtotal,
    tax_amount: quote.taxAmount,
    total_amount: quote.totalAmount,
    items: quote.items,
    remarks: quote.remarks,
    updated_at: new Date().toISOString(),
});

export const getQuotes = async (): Promise<Quote[]> => {
    const { data, error } = await supabase
        .from("quotes")
        .select("*")
        .order("updated_at", { ascending: false });

    if (error) {
        console.error("Error fetching quotes:", error);
        throw error;
    }

    return (data || []).map(mapToQuote);
};

export const getQuote = async (id: string): Promise<Quote | undefined> => {
    const { data, error } = await supabase
        .from("quotes")
        .select("*")
        .eq("id", id)
        .single();

    if (error) {
        console.error("Error fetching quote:", error);
        return undefined;
    }

    return data ? mapToQuote(data) : undefined;
};

export const saveQuote = async (quote: Quote): Promise<void> => {
    // Check if exists/Update or Insert
    // For simplicity, we can use upsert if ID is provided.
    // If ID is empty string or temporary ID, we should handle it carefully.

    // In our app, we generate ID on client for LocalStorage. 
    // For Supabase, best to let DB generate UUID or use valid UUIDs.
    // If quote.id is not a valid UUID, Supabase will error.
    // If it's a new quote, quote.id might be a timestamp-based ID from previous logic which is NOT UUID.
    // We should strip ID if it's not a UUID to let Supabase generate one, OR generate UUID client side.

    const dbData = mapToDb(quote);

    // If id looks like a short string (from previous generateId), delete it to let DB gen UUID
    if (quote.id && quote.id.length < 20) {
        delete dbData.id;
    }

    const { error } = await supabase
        .from("quotes")
        .upsert(dbData, { onConflict: 'id' })
        .select();

    if (error) {
        console.error("Error saving quote:", error);
        throw error;
    }
};

export const deleteQuote = async (id: string): Promise<void> => {
    const { error } = await supabase.from("quotes").delete().eq("id", id);

    if (error) {
        console.error("Error deleting quote:", error);
        throw error;
    }
};

export const generateQuoteNumber = (): string => {
    const prefix = "QUO";
    const year = new Date().getFullYear();
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `${prefix}-${year}-${random}`;
}

// Generate UUID for client-side usage if needed (using crypto.randomUUID if available or library)
export const generateId = (): string => {
    // Return empty or valid UUID. For now return empty string to let DB handle it on Insert.
    // Or if editing, we preserve the ID.
    return "";
};
